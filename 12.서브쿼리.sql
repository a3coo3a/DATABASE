-- 서브쿼리
-- 사용법 : ()안에 명시
-- 서브쿼리의 리턴행이 1줄 이하여야 함.

-- 단일행 서브쿼리
-- : 서브쿼리의 결과가 한 행이 나오는 것
SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Nancy';  -- SALARY : 12008

-- Nancy보다 급여가 많은 사람
SELECT *
FROM EMPLOYEES
WHERE SALARY > (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Nancy');

-- EMPLOYEE_ID가 103인 사람의 JOB_ID와 동일한 사람을 찾아라
SELECT *
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 103);  -- JOB_ID : IT_PROG

-- 서브쿼리의 리턴행이 여러개라면 일반 비교 연산으로는 구분할 수 없습니다.
SELECT JOB_ID
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

-- 에러!
-- 에러 메시지 : 단일 행 하위 질의에 2개 이상의 행이 리턴되었습니다.
-- 행이 5개로 나와서 그럼.
SELECT *
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG');


-- 다중행 서브쿼리
-- 서브쿼리의 리턴행이 여러개라면, 다중행 비교 연산자를 사용
SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME = 'David';  -- 60, 80
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME = 'David');

SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David';  -- 4800, 6800, 9500
-- 3개의 값중 맞는게 있는 정보 표기
SELECT *
FROM EMPLOYEES WHERE SALARY IN (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David'); 
-- 급여가 4800보다 큰 사람들
SELECT *
FROM EMPLOYEES
WHERE SALARY > ANY (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');
-- 9500보다 작은 사람들
SELECT *
FROM EMPLOYEES
WHERE SALARY < ANY (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');
-- 9500보다 큰 사람들
SELECT *
FROM EMPLOYEES
WHERE SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');
-- 4800보다 작은 사람들
SELECT *
FROM EMPLOYEES
WHERE SALARY < ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

-- 스칼라 서브쿼리
-- SELECT절안에 서브쿼리가 오는 것
-- LEFT JOIN과 같은 결과
SELECT * FROM DEPARTMENTS;
SELECT * FROM EMPLOYEES;
SELECT FIRST_NAME, 
    (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) 부서명
FROM EMPLOYEES E
ORDER BY FIRST_NAME ASC;
-- 에러
-- 결과가 단일 행의 값이 와야함.
SELECT FIRST_NAME, 
    (SELECT DEPARTMENT_NAME, D.DEPARTMENT_ID FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) 부서명
FROM EMPLOYEES E
ORDER BY FIRST_NAME ASC;

SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 인라인뷰
-- FROM절에 사용하는 서브쿼리
-- 실행순서상 문제가 발생하여 원하는 결과값을 얻지 못함.
SELECT ROWNUM, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE ROWNUM <= 10
ORDER BY SALARY DESC;
-- 그래서 안쪽에서 ORDER BY실행후 밖에서 조회 실행
SELECT 
    ROWNUM, FIRST_NAME, SALARY
FROM (
        SELECT * 
        FROM EMPLOYEES 
        ORDER BY SALARY DESC
      )
WHERE ROWNUM <= 10;


SELECT 
    ROWNUM, FIRST_NAME, SALARY
FROM (
        SELECT * 
        FROM EMPLOYEES 
        ORDER BY SALARY DESC
      )
WHERE ROWNUM BETWEEN 11 AND 20;

-- 정렬한 후의 번호가 필요한거라 3중 쿼리가 필요한거야
SELECT *
FROM(
    SELECT 
        ROWNUM AS RN, 
        FIRST_NAME, 
        EMAIL,
        HIRE_DATE,
        SALARY
    FROM (
            SELECT * 
            FROM EMPLOYEES 
            ORDER BY SALARY DESC
          )
    )
WHERE RN BETWEEN 11 AND 20;

-- 인라인 뷰
-- 가상데이터 생성
SELECT *
FROM (
    SELECT '홍길동' AS NAME, '20200211' AS TEST FROM DUAL UNION ALL
    SELECT '이순신', '20200301' FROM DUAL UNION ALL
    SELECT '강감찬', '20200501' FROM DUAL UNION ALL
    SELECT '김유신', '20200226' FROM DUAL UNION ALL
    SELECT '이성계', '20200301' FROM DUAL
);
-- 03월 01일 데이터만 추출
SELECT *
FROM (
    SELECT '홍길동' AS NAME, '20200211' AS TEST FROM DUAL UNION ALL
    SELECT '이순신', '20200301' FROM DUAL UNION ALL
    SELECT '강감찬', '20200501' FROM DUAL UNION ALL
    SELECT '김유신', '20200226' FROM DUAL UNION ALL
    SELECT '이성계', '20200301' FROM DUAL
)
WHERE TO_CHAR(TO_DATE(TEST,'YYMMDD'), 'MMDD') = '0301';

SELECT * 
FROM(
    SELECT 
        TO_CHAR(TO_DATE(TEST,'YYMMDD'), 'MMDD') AS MM,
        NAME
    FROM (
        SELECT '홍길동' AS NAME, '20200211' AS TEST FROM DUAL UNION ALL
        SELECT '이순신', '20200301' FROM DUAL UNION ALL
        SELECT '강감찬', '20200501' FROM DUAL UNION ALL
        SELECT '김유신', '20200226' FROM DUAL UNION ALL
        SELECT '이성계', '20200301' FROM DUAL
    )
)
WHERE MM = '0301';